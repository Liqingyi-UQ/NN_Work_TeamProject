import random
random.seed(112358)

import os
import sys

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

from sklearn.inspection import permutation_importance
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import roc_auc_score, accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.utils import resample

# preprocessing
from sklearn import preprocessing 

# TensorFlow and tf.keras
import tensorflow as tf

# Some modules added
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping

%matplotlib inline
# 1.1
# your code here 
# Read the dataset
df = pd.read_csv("flights.csv")
# Delete the value of airport is digit (Noise)
rows_to_drop = df[df['ORIGIN_AIRPORT'].str.isdigit() & df['DESTINATION_AIRPORT'].str.isdigit()].index
df.drop(rows_to_drop, inplace=True)

# Create a variable DELAY_OR_NOT that denotes whether ARRIVAL_DELAY is greater than or equal to 15 minutes
# if delayed, 1; else, 0
df['DELAY_OR_NOT'] = np.where(df['ARRIVAL_DELAY'] >= 15, 1, 0)

# 1.1.2
# your code here
# preprocess the data
# Having checked the data by hand, there is no missing value
categorical_features = ['ORIGIN_AIRPORT', 'DESTINATION_AIRPORT']

# one-hot-encode the non-numeric categorical variables
enc = preprocessing.OneHotEncoder(sparse=False)
encoded_features = enc.fit_transform(df[categorical_features])

# change the result to dataFrame. easy to check and concat
# Notice: old version sklearn using get_feature_names function
columns = enc.get_feature_names(categorical_features)
encoded_df_part = pd.DataFrame(encoded_features, columns=enc.get_feature_names(categorical_features))
df.drop(columns=categorical_features, inplace=True)

# Make sure index alignment
df = df.reset_index(drop=True)
encoded_df_part = encoded_df_part.reset_index(drop=True)

df = pd.concat([df, encoded_df_part], axis=1)

# Get predictors and response
predictors = df.drop(columns=['DELAY_OR_NOT'])
response = df['DELAY_OR_NOT']

# split the data into training and test sets.
X_train, X_test, y_train, y_test = train_test_split(predictors, response, test_size=0.2, random_state=111)

# scale the data and print
# Do not scale y because values of y are 0 and 1
X_train_scaled = StandardScaler().fit_transform(X_train)
X_test_scaled = StandardScaler().fit_transform(X_test)
print(f"X_train shape: {X_train_scaled.shape}")
print(f"X_test shape: {X_test_scaled.shape}")
print(f"y_train : {y_train.shape}")
print(f"y_test : {y_test.shape}")

# 1.2
# build your NN 
# your code here
NN_model = Sequential(name="NN_model")
NN_model.add(Dense(200, activation="relu", kernel_regularizer=keras.regularizers.l1_l2(l1=0.001, l2=0.001),
                   input_shape=(X_train_scaled.shape[1],)))
NN_model.add(Dropout(0.2))
NN_model.add(Dense(200,kernel_regularizer=keras.regularizers.l1_l2(l1=0.001, l2=0.001), activation="relu"))
NN_model.add(Dropout(0.2))
NN_model.add(Dense(1, activation="sigmoid"))


# compile it and run it
# your code here 
early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
NN_model.compile(optimizer=keras.optimizers.Adam(), loss='binary_crossentropy', metrics=['accuracy'])
history = NN_model.fit(X_train_scaled, y_train, batch_size=64, epochs=50, validation_split=0.2,
                       callbacks=[early_stopping])

# plot train and val acc as  a function of epochs
# your code here
plt.title('Model Accuracy')
plt.plot(history.history['accuracy'], label='Train Accuracy', color='#FF9A98')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy', color='#75B594')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.show()

# primer to print: 
# print("NN_model_train_auc:", roc_auc_score(y_train, y_hat))
# your code here 
y_train_predict_pro = NN_model.predict(X_train_scaled)
train_auc = roc_auc_score(y_train, y_train_predict_pro)
print(f"NN_model_train_auc: {train_auc:.4f}")

# your code here

# 1.3
# Fit the logistic regression model
# your code here
# replace the actual response values with the predicted
# values generated by the fitted NN_model
proxy_X_train = X_train_scaled
# pro > 0, the result is 'yes', else 'no'
proxy_y_train = np.where(NN_model.predict(X_train_scaled) > 0.5, 1, 0)
# original proxy_y_train is two-dimensional
proxy_y_train = proxy_y_train.reshape(-1)

# build the model and print the test accuracy
logreg = LogisticRegression(penalty='l2', C=100, solver='lbfgs', max_iter=1000)
logreg.fit(proxy_X_train, proxy_y_train)
proxy_y_test_pred = logreg.predict(X_test_scaled)
proxy_test_accuracy = accuracy_score(y_test, proxy_y_test_pred)
print(f"Logistic Regression Test Accuracy: {proxy_test_accuracy:.4f}")
# The result of local environment is
# NN_model_train_auc: 0.9994
# Logistic Regression Test Accuracy: 0.9802

# 1.4
# 1.4.1
# your code here
def process_data(X_train, feature_1, feature_2=None):
    """
    process data: Set all predictors to their means/modes except for special feature
    parameter:
    X_train: original train data
    feature_1: 'SCHED_DEP_HOUR'
    feature_2: second feature should be kept for real(optional)
    return:
    X_processed: the data processed
    """
    # process the original data, and get the train data
    # set predictors to their modes, there will not one-hot-encoded first
    X_processed = X_train.copy()
    non_one_hot_cols = ['ARRIVAL_DELAY', 'DISTANCE', 'SCHEDULED_TIME', 'MONTH', 'SCHED_DEP_HOUR', 'SCHED_ARR_HOUR',
                        'FLIGHT_COUNT', 'DAY_OF_WEEK']
    # deal with the numerical data
    if feature_2 is not None:
        numeric_cols = X_train.select_dtypes(include=[np.number]).columns.difference([feature_1, feature_2])
    else:
        numeric_cols = X_train.select_dtypes(include=[np.number]).columns.difference([feature_1])

    X_processed[numeric_cols] = X_train[numeric_cols].mean()

    # deal with the category data(one-hot-encoded)
    one_hot_cols = X_train.columns.difference(non_one_hot_cols)
    X_processed[one_hot_cols] = X_train[one_hot_cols].mode().iloc[0]

    return X_processed

def predict_and_plot(model, X_processed, feature_1, feature_2=None):
    """
    Using NN model to predict and plot the predicted probabilities vs features
    parameter::
    model: NN model
    X_processed: the data processed
    feature_1: the first feature kept true value
    feature_2: the second feature kept true value
    """
    # predict
    predicted_pro = model.predict(X_processed)

    # plot
    if feature_2:
        plt.scatter(X_processed[feature_1], X_processed[feature_2], c=predicted_pro, cmap='viridis',
                    alpha=0.75)
        plt.colorbar(label='Predicted Probability of Delay')
        plt.xlabel(feature_1)
        plt.ylabel(feature_2)
        plt.title(f'Predicted Delay Probability vs. {feature_1} and {feature_2}')
        plt.show()
    else:
        plt.scatter(X_processed[feature_1], predicted_pro, c=predicted_pro, cmap='viridis',
                    alpha=0.75)
        plt.colorbar(label='Predicted Probability of Delay')
        plt.xlabel(feature_1)
        plt.ylabel('Predicted Probability of Delay')
        plt.title(f'Predicted Delay Probability vs. {feature_1}')
        plt.show()

X_processed_1 = process_data(X_train, 'SCHED_DEP_HOUR')
predict_and_plot(NN_model, X_processed_1, 'SCHED_DEP_HOUR')

解释
The chart shows that as the scheduled departure time (SCHED_DEP_HOUR) increases, the probability of a flight being delayed decreases. 
The probability of delays is higher from the midnight to early morning hours, while the probability of delays decreases significantly towards the afternoon and evening hours

# 1.4.2
# your code here
X_processed_2 = process_data(X_train, 'SCHED_DEP_HOUR', 'FLIGHT_COUNT')
predict_and_plot(NN_model, X_processed_2, 'SCHED_DEP_HOUR', 'FLIGHT_COUNT')

# 1.4.3
# your code here
X_processed_3 = process_data(X_train, 'SCHED_DEP_HOUR', 'SCHED_ARR_HOUR')
predict_and_plot(NN_model, X_processed_3, 'SCHED_DEP_HOUR', 'SCHED_ARR_HOUR')

# 1.4.4
# your code here
X_processed_4 = process_data(X_train, 'SCHED_DEP_HOUR', 'DISTANCE')
predict_and_plot(NN_model, X_processed_4, 'SCHED_DEP_HOUR', 'DISTANCE')

解释
1. Flight delays are related to departure time and number of flights: the probability of delay is higher in the morning, especially when there are more flights, the probability of delay increases significantly. 
2. When departure and arrival times are both early (such as early morning to morning), the probability of delay is higher; and when departure and arrival times are later, the probability of delay decreases. 
3. The probability of delay varies with departure time, but is less correlated with distance

# 1.5
def progressbar(n_step, n_total):
    """Prints self-updating progress bar to stdout to track for-loop progress
    
    There are entire 3rd-party libraries dedicated to custom progress-bars.
    A simple function like this is often more than enough to get the job done.
    
    :param n_total: total number of expected for-loop iterations
    :type n_total: int
    :param n_step: current iteration number, starting at 0
    :type n_step: int

    .. example::
    
        for i in range(n_iterations):
            progressbar(i, n_iterations)
            
    .. source:
    
        This function is a simplified version of code found here:
        https://stackoverflow.com/questions/3160699/python-progress-bar/15860757#15860757
    """
    n_step = n_step + 1
    barlen = 50
    progress = n_step / n_total
    block = int(round(barlen * progress))
    status = ""
    if n_step == n_total:
        status = "Done...\r\n\n"
    text = "\r [{0}] {1}/{2} {3}".format(
        "=" * block + "-" * (barlen - block),
        n_step,
        n_total,
        status,
    )
    sys.stdout.write(text)
    sys.stdout.flush()

%%time
# Bootstrap and train your networks and get predictions on fixed X test
# your code here


# generate your plot
# your code here

# 1.5此处要写解释
# 1.6
# your code here

# 1.6此处要写解释

# 2.1
# your code here 

# 2.2
# your code here

# 2.2此处要写解释

# 2.3.1
# your code here

# 2.3.2
# your code here

# 2.3.3
# your code here

# 2.3.4
# your code here
